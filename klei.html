<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive 3D Globe</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: sans-serif; 
      background: #000000;
      position: relative;
    }
    
    canvas { display: block; }
    
    #stars {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }
    
    .star {
      position: absolute;
      background: white;
      border-radius: 50%;
      animation: twinkle 3s infinite ease-in-out;
    }
    
    @keyframes twinkle {
      0%, 100% { opacity: 0.3; transform: scale(0.8); }
      50% { opacity: 1; transform: scale(1.2); }
    }

    #title {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      font-size: 2em;
      font-weight: bold;
      color: white;
      text-shadow: 2px 2px 5px black;
      z-index: 10;
      pointer-events: none;
    }

    #banner {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
      font-size: 1.5em;
      font-weight: bold;
      z-index: 10;
      pointer-events: none;
    }

    #banner span {
      display: inline-block;
      animation: wave 1.5s infinite ease-in-out;
      text-shadow: 2px 2px 4px black;
      white-space: nowrap;
    }

    @keyframes wave {
      0% { transform: translateY(0); }
      25% { transform: translateY(-8px); }
      50% { transform: translateY(0); }
      75% { transform: translateY(8px); }
      100% { transform: translateY(0); }
    }

    .letter {
      display: inline-block;
      animation: wave 1.5s infinite ease-in-out;
      text-shadow: 1px 1px 2px black;
    }

    .letter:nth-child(6n+1) { color: #d100ff; }
    .letter:nth-child(6n+2) { color: #a100ff; }
    .letter:nth-child(6n+3) { color: #6f00ff; }
    .letter:nth-child(6n+4) { color: #4000ff; }
    .letter:nth-child(6n+5) { color: #0074ff; }
    .letter:nth-child(6n) { color: #00e0ff; }

    #controls {
      position: absolute;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(30, 30, 30, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 0;
      color: white;
      font-family: 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      z-index: 99;
      display: none;
      flex-direction: column;
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
      overflow: hidden;
      transition: all 0.3s ease;
      max-height: 0;
      opacity: 0;
    }

    #controls.visible {
      max-height: 200px;
      opacity: 1;
      padding: 12px 20px;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-group label {
      min-width: 60px;
      font-weight: 500;
      color: #ccc;
    }

    #controls input {
      background: #1e1e1e;
      color: #fff;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 6px 10px;
      width: 110px;
      font-size: 14px;
    }

    #controls input:focus {
      outline: none;
      border-color: #00ccff;
      background-color: #2b2b2b;
    }

    #toggleControls {
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(30, 30, 30, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      padding: 12px;
      color: white;
      cursor: pointer;
      z-index: 100;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #toggleControls:hover {
      background: rgba(50, 50, 50, 0.9);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateX(-50%) translateY(-2px);
    }

    .control-content {
      padding: 12px 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
  </style>
</head>
<body>
  <div id="stars"></div>
  <div id="title">The World of Klei</div>
  <div id="banner"><span id="waveText">Made with love for Reeves</span></div>
  <button id="toggleControls">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 2c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8 3.58-8 8-8zm0 2c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 2c2.21 0 4 1.79 4 4s-1.79 4-4 4-4-1.79-4-4 1.79-4 4-4z"/>
    </svg>
  </button>
  <div id="controls">
    <div class="control-content">
      <div>
        <label>Point A:</label>
        Lat    <input id="latA" type="number" value="35" step="0.01">
        Lon    <input id="lonA" type="number" value="20" step="0.01">
      </div>
      <div>
        <label>Point B:</label>
        Lat <input id="latB" type="number" value="21" step="0.01">
        Lon <input id="lonB" type="number" value="-98" step="0.01">
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.148.0';
    import { OrbitControls } from 'https://esm.sh/three@0.148.0/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 2.5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0); // Transparent background
    document.body.appendChild(renderer.domElement);

    const RADIUS = 1.01;
    let markerA, markerB, arc, distanceText;
    let shipMaterial = null;
    let raycaster, mouse, isDragging = false, draggedMarker = null;
    let arcUniforms = null;
    const clock = new THREE.Clock();

    const geometry = new THREE.SphereGeometry(1, 64, 64);
    const texture = new THREE.TextureLoader().load('https://papaya.party/img/klei.png');
    const material = new THREE.MeshStandardMaterial({ map: texture });
    const globe = new THREE.Mesh(geometry, material);
    scene.add(globe);

    scene.add(new THREE.AmbientLight(0xffffff, 1));

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = false;
    controls.minDistance = 1.5;
    controls.maxDistance = 3;

    // Initialize raycaster and mouse for dragging
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    raycaster.params.Sprite.threshold = 1.5;

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (arcUniforms) {
        arcUniforms.time.value += delta;
      }
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Helper to pick marker under mouse
    function getMarkerUnderMouse() {
      // Cast against the whole scene and pick the first sprite marked as a marker
      const hits = raycaster.intersectObjects(scene.children, true);
      for (let i = 0; i < hits.length; i++) {
        const obj = hits[i].object;
        if (obj && obj.isSprite && obj.userData && obj.userData.isMarker) {
          return obj;
        }
      }
      return null;
    }

    // Mouse event handlers for dragging
    function onMouseDown(event) {
      event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hit = getMarkerUnderMouse();
      // If hovering a marker, stop controls from interpreting this as a rotate start
      if (getMarkerUnderMouse()) {
        event.stopPropagation();
      }
      if (hit) {
        isDragging = true;
        draggedMarker = hit;
        controls.enabled = false;
        renderer.domElement.style.cursor = 'grabbing';
        // NOTE: Do not snap the marker to the globe here; wait for onMouseMove
      }
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      if (!isDragging) {
        const over = getMarkerUnderMouse();
        renderer.domElement.style.cursor = over ? 'grab' : 'default';
        return; // only move the globe point when actively dragging
      }

      // Only runs if dragging:
      if (!draggedMarker) return;
      event.preventDefault();
      const intersects = raycaster.intersectObject(globe);
      if (intersects.length > 0) {
        const point = intersects[0].point;
        const normalizedPoint = point.normalize();
        // Update marker position
        draggedMarker.position.copy(normalizedPoint.multiplyScalar(RADIUS));
        // Convert 3D position back to lat/lon using the same coordinate system as latLongToVector3
        const lat = 90 - Math.acos(normalizedPoint.y / RADIUS) * (180 / Math.PI);
        const lon = Math.atan2(normalizedPoint.z, -normalizedPoint.x) * (180 / Math.PI) - 180;
        // Update input fields
        if (draggedMarker === markerA) {
          document.getElementById('latA').value = lat.toFixed(2);
          document.getElementById('lonA').value = lon.toFixed(2);
        } else if (draggedMarker === markerB) {
          document.getElementById('latB').value = lat.toFixed(2);
          document.getElementById('lonB').value = lon.toFixed(2);
        }
      }
    }

    function onMouseUp(event) {
      if (isDragging) {
        isDragging = false;
        draggedMarker = null;
        controls.enabled = true;
        renderer.domElement.style.cursor = 'default';
        // Update the path after dragging is complete
        updateArcFromInputs();
      }
    }

    // Add event listeners
    renderer.domElement.addEventListener('mousedown', onMouseDown);
    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('mouseup', onMouseUp);
    window.addEventListener('mouseup', onMouseUp);
    window.addEventListener('mouseleave', onMouseUp);
    // Pointer events for wider device support
    renderer.domElement.addEventListener('pointerdown', onMouseDown);
    renderer.domElement.addEventListener('pointermove', onMouseMove);
    renderer.domElement.addEventListener('pointerup', onMouseUp);

    function latLongToVector3(lat, lon, radius) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lon + 180) * (Math.PI / 180);
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      return new THREE.Vector3(x, y, z);
    }

    function haversine(lat1, lon1, lat2, lon2) {
      const toRad = x => (x * Math.PI) / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      return 6371 * 2 * Math.asin(Math.sqrt(a));
    }

    function findOceanPath(start, end, isOcean) {
      const step = 5;
      const queue = [{ lat: start.lat, lon: start.lon, cost: 0, path: [] }];
      const visited = new Set();

      function hash(lat, lon) {
        return `${lat.toFixed(2)}|${lon.toFixed(2)}`;
      }

      while (queue.length > 0) {
        queue.sort((a, b) => a.cost + haversine(a.lat, a.lon, end.lat, end.lon) - (b.cost + haversine(b.lat, b.lon, end.lat, end.lon)));
        const node = queue.shift();
        const { lat, lon, path } = node;
        const key = hash(lat, lon);
        if (visited.has(key)) continue;
        visited.add(key);

        const newPath = [...path, { lat, lon }];
        if (haversine(lat, lon, end.lat, end.lon) < 600) return newPath;

        const directions = [
          [step, 0], [-step, 0], [0, step], [0, -step],
          [step, step], [-step, step], [step, -step], [-step, -step]
        ];
        for (const [dLat, dLon] of directions) {
          const nLat = lat + dLat;
          const nLon = lon + dLon;
          if (nLat > 90 || nLat < -90) continue;
          if (!isOcean(nLat, nLon)) continue;
          const g = node.cost + haversine(lat, lon, nLat, nLon);
          queue.push({ lat: nLat, lon: nLon, cost: g, path: newPath });
        }
      }
      return [];
    }

    const samplingCanvas = document.createElement('canvas');
    const ctx = samplingCanvas.getContext('2d');
    const mapImage = new Image();
    mapImage.crossOrigin = 'anonymous';
    mapImage.src = 'https://papaya.party/img/klei-3.png';

    mapImage.onload = () => {
      samplingCanvas.width = mapImage.width;
      samplingCanvas.height = mapImage.height;
      ctx.drawImage(mapImage, 0, 0);
      updateArcFromInputs();
    };

    function isOcean(lat, lon) {
      if (!ctx) return false;

      const x = Math.floor(((lon + 180) / 360) * samplingCanvas.width);
      const y = Math.floor(((90 - lat) / 180) * samplingCanvas.height);

      const [r, g, b] = ctx.getImageData(x, y, 1, 1).data;

      // ✅ Matches your textured water style
      const isDarkOcean = r >= 40 && r <= 100 &&
                          g >= 60 && g <= 120 &&
                          b >= 70 && b <= 150;

      const isCoolColor = b >= g && b >= r;

      return b >= 180 && r <= 10 && g <= 10//&& isCoolColor;
    }

    function debugOceanGrid() {
      const dotMat = new THREE.MeshBasicMaterial({ color: 0x2266ff });
      const dotGeo = new THREE.SphereGeometry(0.004, 6, 6);

      for (let lat = -80; lat <= 80; lat += 10) {
        for (let lon = -180; lon <= 180; lon += 10) {
          if (isOcean(lat, lon)) {
            const marker = new THREE.Mesh(dotGeo, dotMat);
            marker.position.copy(latLongToVector3(lat, lon, RADIUS));
            scene.add(marker);
          }
        }
      }
    }


    // Create a golden ship texture without external assets
    function createGoldenShipTexture(size = 256) {
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');

      // Clear
      ctx.clearRect(0, 0, size, size);

      // Helpers
      const cx = size / 2;
      const baseY = size * 0.70;

      // Gold gradients
      const goldHull = ctx.createLinearGradient(0, 0, size, 0);
      goldHull.addColorStop(0, '#8a6f00');
      goldHull.addColorStop(0.3, '#b99100');
      goldHull.addColorStop(0.6, '#ffd34d');
      goldHull.addColorStop(1, '#8a6f00');

      const goldSail = ctx.createLinearGradient(0, 0, 0, size);
      goldSail.addColorStop(0, '#fff3b0');
      goldSail.addColorStop(1, '#d8b400');

      const outline = '#5c4a00';

      // Draw hull
      ctx.beginPath();
      ctx.moveTo(size * 0.18, baseY);
      ctx.lineTo(size * 0.82, baseY);
      ctx.lineTo(size * 0.70, baseY - size * 0.10);
      ctx.lineTo(size * 0.30, baseY - size * 0.10);
      ctx.closePath();
      ctx.fillStyle = goldHull;
      ctx.fill();
      ctx.lineWidth = Math.max(1, size * 0.01);
      ctx.strokeStyle = outline;
      ctx.stroke();

      // Draw mast
      const mastH = size * 0.42;
      const mastW = Math.max(2, size * 0.02);
      ctx.fillStyle = goldHull;
      ctx.fillRect(cx - mastW / 2, baseY - mastH, mastW, mastH);
      ctx.strokeRect(cx - mastW / 2, baseY - mastH, mastW, mastH);

      // Draw large sail (left)
      ctx.beginPath();
      ctx.moveTo(cx - mastW / 2, baseY - mastH + size * 0.02);
      ctx.lineTo(cx - size * 0.28, baseY - mastH * 0.15);
      ctx.lineTo(cx - mastW / 2, baseY - size * 0.12);
      ctx.closePath();
      ctx.fillStyle = goldSail;
      ctx.fill();
      ctx.strokeStyle = outline;
      ctx.stroke();

      // Draw small sail (right)
      ctx.beginPath();
      ctx.moveTo(cx + mastW / 2, baseY - mastH * 0.45);
      ctx.lineTo(cx + size * 0.22, baseY - mastH * 0.25);
      ctx.lineTo(cx + mastW / 2, baseY - size * 0.30);
      ctx.closePath();
      ctx.fillStyle = goldSail;
      ctx.fill();
      ctx.stroke();

      // Flag
      ctx.beginPath();
      ctx.moveTo(cx + mastW / 2, baseY - mastH);
      ctx.lineTo(cx + size * 0.10, baseY - mastH + size * 0.05);
      ctx.lineTo(cx + mastW / 2, baseY - mastH + size * 0.09);
      ctx.closePath();
      ctx.fillStyle = goldHull;
      ctx.fill();
      ctx.stroke();

      // Slight glow
      const glow = ctx.createRadialGradient(cx, baseY - mastH * 0.4, size * 0.05, cx, baseY - mastH * 0.4, size * 0.35);
      glow.addColorStop(0, 'rgba(255, 215, 0, 0.35)');
      glow.addColorStop(1, 'rgba(255, 215, 0, 0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(cx, baseY - mastH * 0.4, size * 0.35, 0, Math.PI * 2);
      ctx.fill();

      const texture = new THREE.CanvasTexture(canvas);
      texture.anisotropy = 8;
      texture.needsUpdate = true;
      return texture;
    }

    // === Pathfinding helpers ===
    // Smooth a path of lat/lon points using Chaikin's algorithm
    function smoothPath(path, iterations = 2) {
      let result = path.slice();
      for (let iter = 0; iter < iterations; iter++) {
        let newPath = [];
        newPath.push(result[0]);
        for (let i = 0; i < result.length - 1; i++) {
          const a = result[i], b = result[i + 1];
          const lat1 = a.lat, lon1 = a.lon, lat2 = b.lat, lon2 = b.lon;
          newPath.push({
            lat: lat1 * 0.75 + lat2 * 0.25,
            lon: lon1 * 0.75 + lon2 * 0.25
          });
          newPath.push({
            lat: lat1 * 0.25 + lat2 * 0.75,
            lon: lon1 * 0.25 + lon2 * 0.75
          });
        }
        newPath.push(result[result.length - 1]);
        result = newPath;
      }
      return result;
    }

    // Convert array of {lat,lon} to array of Vector3 (on the globe)
    function pathToVectors(path, radius = RADIUS) {
      return path.map(({ lat, lon }) => latLongToVector3(lat, lon, radius));
    }

    // Slerp between two lat/lon points on a sphere
    function slerpOnSphere(a, b, t, radius) {
      // Convert to Cartesian
      const va = latLongToVector3(a.lat, a.lon, radius);
      const vb = latLongToVector3(b.lat, b.lon, radius);
      return va.clone().lerp(vb, t).normalize().multiplyScalar(radius);
    }

    // Smooth path of Vector3s using Chaikin's algorithm, preserving endpoints
    function smoothOnSphere(points, iterations = 2, radius = RADIUS) {
      let result = points.slice();
      for (let iter = 0; iter < iterations; iter++) {
        let newPath = [];
        newPath.push(result[0]);
        for (let i = 0; i < result.length - 1; i++) {
          const a = result[i], b = result[i + 1];
          // Weighted averages, then project to sphere
          let p1 = a.clone().multiplyScalar(0.75).add(b.clone().multiplyScalar(0.25)).normalize().multiplyScalar(radius);
          let p2 = a.clone().multiplyScalar(0.25).add(b.clone().multiplyScalar(0.75)).normalize().multiplyScalar(radius);
          newPath.push(p1, p2);
        }
        newPath.push(result[result.length - 1]);
        result = newPath;
      }
      return result;
    }

    function updateArcFromInputs() {
      const latA = parseFloat(document.getElementById('latA').value);
      const lonA = parseFloat(document.getElementById('lonA').value);
      const latB = parseFloat(document.getElementById('latB').value);
      const lonB = parseFloat(document.getElementById('lonB').value);

      console.log("Updating arc with coordinates:", latA, lonA, latB, lonB);
      console.log("Context available:", !!ctx, "Image width:", mapImage.width);

      if (!ctx || mapImage.width === 0) {
        console.warn("Context or image not ready, skipping update");
        return;
      }

      if (arc) scene.remove(arc);
      if (markerA) scene.remove(markerA);
      if (markerB) scene.remove(markerB);
      if (distanceText) scene.remove(distanceText);

      // --- Ocean path validation + fallback ---
      let oceanPath = findOceanPath({ lat: latA, lon: lonA }, { lat: latB, lon: lonB }, isOcean);
      let isFallbackPath = false;
      if (!oceanPath || oceanPath.length === 0) {
        console.warn("Ocean path failed. Drawing straight line instead.");
        oceanPath = [
          { lat: latA, lon: lonA },
          { lat: latB, lon: lonB }
        ];
        isFallbackPath = true;
      }

      // Fallback: draw a red dashed line if not valid ocean path
      if (isFallbackPath) {
        // Fallback: draw a red dashed line following the globe surface (great-circle approximation)
        {
          const startV = latLongToVector3(latA, lonA, RADIUS);
          const endV   = latLongToVector3(latB, lonB, RADIUS);
          const vA = startV.clone().normalize();
          const vB = endV.clone().normalize();
          const segments = 128; // smoother arc along the surface
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            // approximate spherical interpolation by normalizing the lerp result
            const p = vA.clone().lerp(vB, t).normalize().multiplyScalar(RADIUS);
            points.push(p);
          }
          const geom = new THREE.BufferGeometry().setFromPoints(points);
          const mat  = new THREE.LineDashedMaterial({ color: 0xff0000, dashSize: 0.07, gapSize: 0.035 });
          arc = new THREE.Line(geom, mat);
          arc.computeLineDistances();
          scene.add(arc);
        }
      } else {
        // Valid ocean path: rebuild arcPoints with exact endpoints and interior samples
        const rebuilt = [];
        rebuilt.push(latLongToVector3(latA, lonA, RADIUS));
        for (let i = 0; i < oceanPath.length - 1; i++) {
          const a = oceanPath[i];
          const b = oceanPath[i + 1];
          const segKm = haversine(a.lat, a.lon, b.lat, b.lon);
          const steps = Math.max(6, Math.ceil(segKm / 120));
          for (let j = 1; j < steps; j++) { // start at 1 to avoid duplicating anchors
            const t = j / steps;
            rebuilt.push(slerpOnSphere(a, b, t, RADIUS));
          }
        }
        rebuilt.push(latLongToVector3(latB, lonB, RADIUS));

        // Smooth corners (preserves endpoints)
        const controlPoints = smoothOnSphere(rebuilt, 2, RADIUS);

        const curve = new THREE.CatmullRomCurve3(controlPoints, false, 'centripetal', 0.5);
        const tubularSegments = Math.max(200, controlPoints.length * 6);
        const tubeRadius = 0.003;
        const radialSegments = 8;
        const closed = false;
        const tubeGeometry = new THREE.TubeGeometry(curve, tubularSegments, tubeRadius, radialSegments, closed);
        // Shader for golden base with traveling glow
        arcUniforms = {
          time: { value: 0 },
          baseColor: { value: new THREE.Color(0xC9A227) },   // rich gold base
          glowColor: { value: new THREE.Color(0xFFD700) },   // bright gold glow
          glowWidth: { value: 0.05 },                         // narrower glow band (0..1 along length)
          glowStrength: { value: 1.5 },                       // additive intensity of the glow
          speed: { value: 0.45 }                              // one-way movement speed
        };
        const vertexShader = `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `;
        const fragmentShader = `
          precision mediump float;
          varying vec2 vUv;
          uniform float time;
          uniform vec3 baseColor;
          uniform vec3 glowColor;
          uniform float glowWidth;
          uniform float glowStrength;
          uniform float speed;
          void main() {
            vec3 color = baseColor;
            float center = fract(time * speed);
            float dist = abs(vUv.y - center);
            float sigma = glowWidth * 0.5;
            float glow = exp(- (dist * dist) / (2.0 * sigma * sigma));
            color += glowColor * glow * glowStrength;
            float rim = smoothstep(0.5, 0.0, abs(vUv.x - 0.5));
            color += glowColor * 0.2 * rim;
            gl_FragColor = vec4(color, 1.0);
          }
        `;
        const arcMaterial = new THREE.ShaderMaterial({
          uniforms: arcUniforms,
          vertexShader,
          fragmentShader,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        arc = new THREE.Mesh(tubeGeometry, arcMaterial);
        scene.add(arc);
      }

      // Use a procedurally drawn golden ship sprite (no external asset)
      if (!shipMaterial) {
        const shipTexture = createGoldenShipTexture(256);
        shipMaterial = new THREE.SpriteMaterial({ map: shipTexture, transparent: true, depthTest: false, depthWrite: false });
      }
      markerA = new THREE.Sprite(shipMaterial);
      markerA.position.copy(latLongToVector3(latA, lonA, RADIUS));
      markerA.scale.set(0.12, 0.12, 1);
      markerA.center.set(0.5, 0.5);
      markerA.userData.isMarker = true;
      markerA.frustumCulled = false;
      markerA.renderOrder = 10;
      scene.add(markerA);
      markerB = new THREE.Sprite(shipMaterial);
      markerB.position.copy(latLongToVector3(latB, lonB, RADIUS));
      markerB.scale.set(0.12, 0.12, 1);
      markerB.center.set(0.5, 0.5);
      markerB.userData.isMarker = true;
      markerB.frustumCulled = false;
      markerB.renderOrder = 10;
      scene.add(markerB);

      // Calculate total distance of the path
      let totalDistance = 0;
      for (let i = 0; i < oceanPath.length - 1; i++) {
        const a = oceanPath[i];
        const b = oceanPath[i + 1];
        totalDistance += haversine(a.lat, a.lon, b.lat, b.lon);
      }
      // Create distance text bubble
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 128;
      // Create bubble background
      context.fillStyle = 'rgba(0, 0, 0, 0.8)';
      context.strokeStyle = '#FFD700';
      context.lineWidth = 4;
      // Draw rounded rectangle manually
      const x = 20, y = 20, width = canvas.width - 40, height = canvas.height - 40, radius = 30;
      context.beginPath();
      context.moveTo(x + radius, y);
      context.lineTo(x + width - radius, y);
      context.quadraticCurveTo(x + width, y, x + width, y + radius);
      context.lineTo(x + width, y + height - radius);
      context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      context.lineTo(x + radius, y + height);
      context.quadraticCurveTo(x, y + height, x, y + height - radius);
      context.lineTo(x, y + radius);
      context.quadraticCurveTo(x, y, x + radius, y);
      context.closePath();
      context.fill();
      context.stroke();
      // Add text
      context.fillStyle = '#FFD700';
      context.font = 'bold 60px Arial';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      const distanceString = `${totalDistance.toFixed(0)} km`;
      context.fillText(distanceString, canvas.width / 2, canvas.height / 2);
      // Create texture and material
      const texture = new THREE.CanvasTexture(canvas);
      const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
      distanceText = new THREE.Sprite(mat);
      // Position the bubble at the midpoint of the path
      const midIndex = Math.floor(oceanPath.length / 2);
      const midPoint = oceanPath[midIndex];
      const midPosition = latLongToVector3(midPoint.lat, midPoint.lon, RADIUS + 0.05);
      distanceText.position.copy(midPosition);
      distanceText.scale.set(0.2, 0.05, 1);
      scene.add(distanceText);
      console.log("Ocean path length:", oceanPath.length);
      console.log("Total distance:", totalDistance.toFixed(0), "km");
    }

    window.addEventListener('DOMContentLoaded', () => {
      // Create twinkling stars
      const starsContainer = document.getElementById('stars');
      const numStars = 200;
      
      for (let i = 0; i < numStars; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        
        // Random position
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        
        // Random size
        const size = Math.random() * 3 + 1;
        star.style.width = size + 'px';
        star.style.height = size + 'px';
        
        // Random animation delay
        star.style.animationDelay = Math.random() * 3 + 's';
        star.style.animationDuration = (Math.random() * 2 + 2) + 's';
        
        starsContainer.appendChild(star);
      }

      document.querySelectorAll('#latA, #lonA, #latB, #lonB').forEach(input => {
        input.addEventListener('input', updateArcFromInputs);
      });

      // Toggle controls functionality
      const toggleButton = document.getElementById('toggleControls');
      const controls = document.getElementById('controls');
      let controlsVisible = false;

      toggleButton.addEventListener('click', () => {
        controlsVisible = !controlsVisible;
        if (controlsVisible) {
          controls.style.display = 'flex';
          // Small delay to ensure display is set before adding class
          setTimeout(() => controls.classList.add('visible'), 10);
        } else {
          controls.classList.remove('visible');
          // Wait for animation to complete before hiding
          setTimeout(() => {
            if (!controlsVisible) {
              controls.style.display = 'none';
            }
          }, 300);
        }
        
        // Update icon based on state
        const svg = toggleButton.querySelector('svg');
        if (controlsVisible) {
          svg.innerHTML = '<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>';
        } else {
          svg.innerHTML = '<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 2c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8 3.58-8 8-8zm0 2c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 2c2.21 0 4 1.79 4 4s-1.79 4-4 4-4-1.79-4-4 1.79-4 4-4z"/>';
        }
      });

      const waveText = document.getElementById('waveText');
      const wave = waveText.textContent;
      waveText.innerHTML = '';
      wave.split('').forEach((char, i) => {
        const span = document.createElement('span');
        span.className = 'letter';
        span.textContent = char;
        span.style.animationDelay = `${i * 0.1}s`;
        waveText.appendChild(span);
      });
    });
  </script>
</body>
</html>
z